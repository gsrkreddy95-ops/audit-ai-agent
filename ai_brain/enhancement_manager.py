"""
Enhancement Manager
Manages pending enhancement proposals, approvals, and application.
"""

import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


class EnhancementManager:
    """
    Handles storage of pending enhancements generated by Meta-Intelligence,
    provides list/apply operations, and maintains an audit log.
    """

    def __init__(self) -> None:
        self.repo_root = Path(__file__).resolve().parents[1]
        self.enhancement_dir = self.repo_root / "ai_brain" / "enhancements"
        self.enhancement_dir.mkdir(parents=True, exist_ok=True)
        self.ledger_path = self.enhancement_dir / "ledger.json"
        if not self.ledger_path.exists():
            self._save_ledger([])

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #
    def _load_ledger(self) -> List[Dict[str, Any]]:
        try:
            with open(self.ledger_path, "r", encoding="utf-8") as handle:
                return json.load(handle)
        except (json.JSONDecodeError, FileNotFoundError):
            return []

    def _save_ledger(self, records: List[Dict[str, Any]]) -> None:
        with open(self.ledger_path, "w", encoding="utf-8") as handle:
            json.dump(records, handle, indent=2)

    def _update_record(self, updated_record: Dict[str, Any]) -> None:
        records = self._load_ledger()
        new_records = []
        for record in records:
            if record["id"] == updated_record["id"]:
                new_records.append(updated_record)
            else:
                new_records.append(record)
        self._save_ledger(new_records)

    # ------------------------------------------------------------------ #
    # Public API
    # ------------------------------------------------------------------ #
    def register_proposal(self, proposal: Dict[str, Any]) -> Dict[str, Any]:
        records = self._load_ledger()
        record = {
            "id": proposal.get("id") or str(uuid.uuid4()),
            "timestamp": datetime.now().isoformat(),
            "status": "pending",
            **proposal,
        }
        records.append(record)
        self._save_ledger(records)
        return record

    def list_enhancements(self, status: Optional[str] = None) -> List[Dict[str, Any]]:
        records = self._load_ledger()
        if status:
            return [r for r in records if r.get("status") == status]
        return records

    def get_proposal(self, proposal_id: str) -> Optional[Dict[str, Any]]:
        records = self._load_ledger()
        for record in records:
            if record["id"] == proposal_id:
                return record
        return None

    # ------------------------------------------------------------------ #
    # Patch application utilities
    # ------------------------------------------------------------------ #
    def apply_proposal(self, proposal_id: str) -> Dict[str, Any]:
        record = self.get_proposal(proposal_id)
        if not record:
            raise ValueError(f"Enhancement {proposal_id} not found")
        if record.get("status") != "pending":
            raise ValueError(f"Enhancement {proposal_id} already {record.get('status')}")

        modifications = record.get("files") or []
        if not modifications:
            raise ValueError("Enhancement does not define any file modifications")

        backups: List[Dict[str, Any]] = []
        try:
            for mod in modifications:
                backups.append(self._apply_modification(mod))
        except Exception as exc:
            # Roll back previous modifications
            for backup in reversed(backups):
                path = backup["path"]
                if backup["operation"] == "create":
                    if path.exists():
                        path.unlink()
                else:
                    path.write_text(backup["original"], encoding="utf-8")
            raise RuntimeError(f"Failed to apply enhancement {proposal_id}: {exc}") from exc

        record["status"] = "applied"
        record["applied_at"] = datetime.now().isoformat()
        self._update_record(record)

        return record

    def _apply_modification(self, modification: Dict[str, Any]) -> Dict[str, Any]:
        operation = modification.get("operation", "replace")
        relative_path = modification.get("path")
        if not relative_path:
            raise ValueError("Modification missing 'path'")
        file_path = (self.repo_root / relative_path).resolve()

        if operation == "replace":
            search = modification.get("search")
            replace = modification.get("replace")
            if not search or replace is None:
                raise ValueError("Replace operation requires 'search' and 'replace'")
            original_text = file_path.read_text(encoding="utf-8")
            if search not in original_text:
                raise ValueError(f"Search block not found in {relative_path}")
            updated_text = original_text.replace(search, replace, 1)
            file_path.write_text(updated_text, encoding="utf-8")
            return {"operation": "replace", "path": file_path, "original": original_text}

        if operation == "append":
            content = modification.get("content")
            if content is None:
                raise ValueError("Append operation requires 'content'")
            original_text = file_path.read_text(encoding="utf-8")
            file_path.write_text(original_text + content, encoding="utf-8")
            return {"operation": "append", "path": file_path, "original": original_text}

        if operation == "create":
            content = modification.get("content")
            if content is None:
                raise ValueError("Create operation requires 'content'")
            if file_path.exists():
                raise ValueError(f"File already exists: {relative_path}")
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content, encoding="utf-8")
            return {"operation": "create", "path": file_path, "original": ""}

        raise ValueError(f"Unsupported operation: {operation}")

